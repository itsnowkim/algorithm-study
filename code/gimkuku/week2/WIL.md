## 양과 늑대


### 회고
- 진짜 겁나 어려웠다. 다른 사람 풀이보고도 이해 안됐음.. 
- 특히 왔다갔다해서 모든 경우의 탐색을 해야 되는데, 이때 나는 `방문했던 곳을 또 방문해도 된다고 생각`을 해서 더 헤맸다. 


**키 포인트**


`방문했던 노드 주변의 노드`는 언제든지 갈 수 있다.


**상세 설명**


일번 예시를 보면 
- 왼쪽에서 양을 한마리 데리고
- 오른쪽으로 가서 양을 두마리 데리고
- 다시 왼쪽으로 가서 양을 데리러 간다.


여기서 내가 했던 실수는, 그렇다면 하나의 노드를 반복해서 지나치는 것이니 중단 (return)을 visited 로 셀수 없다고 생각한 것이다. 
그래서 내가 짠 코드는 root - 왼쪽 양 - 다시 root - 다시 왼쪽 양 ... 과 같이 무한정 반복이 가능해서 `recursive error`가 발생했다. 


그러나 핵심은, 방문했던 노드는 `양/늑대 상관없이` 다시 방문할 수 있다는 점이다. 즉, 방문했던 노드는 언제든지 재방문이 가능하며 방문했던 노드와 `인접한 노드도 언제든지` 방문이 가능하다. 


따라서 나는 
1. 언제든지 방문이 가능한 노드를 cango = [] 배열에 넣고
2. 새로운 노드에 방문할 때 마다 인접 노드를 cango 배열에 넣어 업데이트 하며
3. 매번 for 문으로 cango (= 방문할 수 있는 노드)를 모두 탐색했다.

그러면서 max_sheep을 업데이트 해주면 된다. 

```
# 현재 노드와 인접한 노드를 cango 배열에 넣어줌
cango = cango + nextnode(now,edges)

# 현재 노드에서 갈 수 있는 모든 노드를 재귀로 탐색 
for i in cango:
    # 방문을 안했었던 노드 방문
    if new_visit[i]:
        max_sheep = max(max_sheep, dfs(i, sheep, wolf, info, edges, cango, new_visit))
```

- 이렇게 쓰면서 정리하다보니.. 방문했던 노드를 하나의 노드로 합친다고 생각하면 이해가 더 쉬울 것 같다. 구현은 이렇게 생각하면 더 어렵겠지만..? 




## 파괴되지 않은 건물


### 회고 
- 누구나 그랬겠지만 보자마자 쉽네? 했다가 효율성 무슨일..ㅋㅋ 
- 도저히 내 머리로는 모를 것이란 걸 알았기 때문에... 바로 블로그를 검색했다
- `누적합` 을 사용하는 문제


**누적합이란?**
> 리스트 l = [0,0,0,0,0,0] 이라고 둘 때,  리스트 [0] 부터 [3] 을 1로 바꾸어야 한다면 어떻게 할까? 
- 보통 우리는 for 문을 0부터 3까지 돌려 [1,1,1,1,0,0]으로 바꿀 것이다.
- 그런데 누적합은 `시작점과 끝점`에 표시하는 것으로 위의 배열을 나타낼 수 있다. 

```
l = [0,0,0,0,0,0] 일때 타겟이 [1,1,1,1,0,0]이라면,  
multisum_l = [1,0,0,0,-1,0] 
```
- 이때 누적합을 전개하면, 즉 현재의 값에 이전의 값을 더하면
```
l[i] += l[i-1] 
=> 결과
multisum = [1,1,0,0,-1,0]
multisum = [1,1,1,0,-1,0]
multisum = [1,1,1,1,-1,0]
multisum = [1,1,1,1,0,0]
multisum = [1,1,1,1,0,0] <- target
```


**즉 누적합은 시작과 끝에 표시하는 것으로 연속된 수를 표현할 수 있다.**


**이차원 배열에서 누적합**
- 이차원 배열에서는 가로로 한번, 세로로 한번 전개를 해주어야 한다. 
- 따라서 시작점과 끝점을 신경써서 표시해주면 된다. 


예를 들어, (r1,c1) 부터 (r2,c2)까지 degree만큼 더해주고 싶을 때
```
multisum_list[r1][c1] += degree 
multisum_list[r1][c2+1] -= degree    
multisum_list[r2+1][c1] -= degree    
multisum_list[r2+1][c2+1] += degree
```
다음과 같이 시작점에 degree를 더하고, 끝점 +1 인 지점에 degree를 빼준 뒤,


가로로 전개
```
 for i in range(len(board)):
        for j in range(1,len(board[0])):
            multisum_list[i][j] += multisum_list[i][j-1]
```


세로로 전개
```
for i in range(len(board[0])):
        for j in range(1,len(board)):
            multisum_list[j][i] += multisum_list[j-1][i]
```
해주면 된다. 


이렇게 누적합을 사용한다면, 처음에 skill 배열의 크기만큼 돌리며 시작점과 끝점을 표시하고, NxM 보드를 채워주면 되니 최악의 경우 시간복잡도는 O(N*M) 이 된다. 


그러나 누적합을 사용하지 않는다면, 배열 점 마다 skill에 해당이 되는지 확인해야 하므로, 최악의 경우 시간복잡도는 O(N*M*skill)이 된다. 
